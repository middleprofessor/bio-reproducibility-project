gg_list[[label_i]] <- gg
}
}
ycols
ycols_seed
ycols <- NULL
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols_seed <- c("Shoot_biomass", "n_Leaves", "Root.shoot_ratio")
ycols_juv <- c("n_Leaves","Biomass", "Root_biomass")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
gg_list <- list()
stage_j <- "Seedling"
ycols <- ifelse(stage_j=="Seedling", ycols_seed, ycols_juv)
ycols
ycols_seed
length*(ycols_seed)
length(ycols_seed)
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols_seed <- c("Shoot_biomass", "n_Leaves", "Root.shoot_ratio")
ycols_juv <- c("n_Leaves","Biomass", "Root_biomass")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
gg_list <- list()
for(stage_j in c("Seedling", "Juvenile")){
ycols <- ifelse(stage_j=="Seedling", c("Shoot_biomass", "n_Leaves", "Root.shoot_ratio"), c("n_Leaves","Biomass", "Root_biomass"))
for(y in ycols){
subdata <- na.omit(exp2.b[Stage==stage_j &
N > 1, .SD, .SDcols=c(xcols, y)])
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata[Experience=="E", Population])
subdata[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata[Experience=="N", Population])
subdata[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata[, Population.cross:=factor(Population.cross)]
# modeled SE
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata)
fit3.emm <- data.table(summary(emmeans(fit3, specs=c("Treatment", "Experience"))))
# raw SE (how to deal with nested?)
# pooled SE (ignore nested structure)
subdata.pool.SE <- subdata[, .(ybar=mean(get(y)),
SE=sd(get(y))/sqrt(.N)
), by=.(Treatment, Experience)]
# SE of pop means
# no pool (average replicates within pop)
subdata.nopool <- subdata[, .(ybar=mean(get(y))
), by=.(Treatment, Experience, Population)]
subdata.nopool.SE <- subdata.nopool[, .(ybar=mean(ybar),
SE=sd(ybar)/sqrt(.N)
), by=.(Treatment, Experience)]
# modeled SE
pd <- position_dodge(0.5)
gg <- ggplot(data=fit3.emm, aes(x=Treatment, y=emmean, color=Experience, group=Experience)) +
geom_point(position=pd) +
geom_line(position=pd) +
geom_errorbar(aes(min=emmean-SE, max=emmean+SE), position=pd, width=.2) +
ylab(y) +
NULL
#gg
# complete pooling
gg <- ggplot(data=subdata.pool.SE, aes(x=Treatment, y=ybar, color=Experience, group=Experience, shape=Experience)) +
geom_point(position=pd) +
geom_line(position=pd) +
geom_errorbar(aes(min=ybar-SE, max=ybar+SE), position=pd, width=.2) +
ylab(y) +
NULL
label_i <- paste(y, stage_j, sep=".")
gg_list[[label_i]] <- gg
}
}
ycols
ycols
ycols_seed
ycols_juv
ycols
ycols <- NULL
if(stage_j=="Seedling"){
ycols <- ycols_seed}else{
ycols <- ycols_juv}
ycols
stage_j
gg
y
ycols
gg_list <- list()
for(stage_j in c("Seedling", "Juvenile")){
if(stage_j=="Seedling"){
ycols <- ycols_seed}else{
ycols <- ycols_juv}
for(y in ycols){
subdata <- na.omit(exp2.b[Stage==stage_j &
N > 1, .SD, .SDcols=c(xcols, y)])
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata[Experience=="E", Population])
subdata[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata[Experience=="N", Population])
subdata[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata[, Population.cross:=factor(Population.cross)]
# modeled SE
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata)
fit3.emm <- data.table(summary(emmeans(fit3, specs=c("Treatment", "Experience"))))
# raw SE (how to deal with nested?)
# pooled SE (ignore nested structure)
subdata.pool.SE <- subdata[, .(ybar=mean(get(y)),
SE=sd(get(y))/sqrt(.N)
), by=.(Treatment, Experience)]
# SE of pop means
# no pool (average replicates within pop)
subdata.nopool <- subdata[, .(ybar=mean(get(y))
), by=.(Treatment, Experience, Population)]
subdata.nopool.SE <- subdata.nopool[, .(ybar=mean(ybar),
SE=sd(ybar)/sqrt(.N)
), by=.(Treatment, Experience)]
# modeled SE
pd <- position_dodge(0.5)
gg <- ggplot(data=fit3.emm, aes(x=Treatment, y=emmean, color=Experience, group=Experience)) +
geom_point(position=pd) +
geom_line(position=pd) +
geom_errorbar(aes(min=emmean-SE, max=emmean+SE), position=pd, width=.2) +
ylab(y) +
NULL
#gg
# complete pooling
gg <- ggplot(data=subdata.pool.SE, aes(x=Treatment, y=ybar, color=Experience, group=Experience, shape=Experience)) +
geom_point(position=pd) +
geom_line(position=pd) +
geom_errorbar(aes(min=ybar-SE, max=ybar+SE), position=pd, width=.2) +
ylab(y) +
NULL
label_i <- paste(y, stage_j, sep=".")
gg_list[[label_i]] <- gg
}
}
gglist
gg_list
gg_list$n_Leaves.Juvenile
gg_list$Biomass.Juvenile
gg_list$Root_biomass.Juvenile
gg_list$n_Leaves.Juvenile
gg_list$Biomass.Juvenile
gg_list$Root_biomass.Juvenile
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols_seed <- c("Shoot_biomass", "n_Leaves", "Root.shoot_ratio")
ycols_juv <- c("n_Leaves","Biomass", "Root_biomass")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
gg_list <- list()
for(stage_j in c("Seedling", "Juvenile")){
if(stage_j=="Seedling"){
ycols <- ycols_seed}else{
ycols <- ycols_juv}
for(y in ycols){
subdata <- na.omit(exp2.b[Stage==stage_j &
N > 1, .SD, .SDcols=c(xcols, y)])
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata[Experience=="E", Population])
subdata[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata[Experience=="N", Population])
subdata[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata[, Population.cross:=factor(Population.cross)]
# modeled SE
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata)
fit3.emm <- data.table(summary(emmeans(fit3, specs=c("Treatment", "Experience"))))
# raw SE (how to deal with nested?)
# pooled SE (ignore nested structure)
subdata.pool.SE <- subdata[, .(ybar=mean(get(y)),
SE=sd(get(y))/sqrt(.N)
), by=.(Treatment, Experience)]
# SE of pop means
# no pool (average replicates within pop)
subdata.nopool <- subdata[, .(ybar=mean(get(y))
), by=.(Treatment, Experience, Population)]
subdata.nopool.SE <- subdata.nopool[, .(ybar=mean(ybar),
SE=sd(ybar)/sqrt(.N)
), by=.(Treatment, Experience)]
# modeled SE
pd <- position_dodge(0.5)
gg <- ggplot(data=fit3.emm, aes(x=Treatment, y=emmean, color=Experience, group=Experience)) +
geom_point(position=pd) +
geom_line(position=pd) +
geom_errorbar(aes(min=emmean-SE, max=emmean+SE), position=pd, width=.2) +
ylab(y) +
NULL
#gg
# complete pooling
gg <- ggplot(data=subdata.pool.SE, aes(x=Treatment, y=ybar, color=Experience, group=Experience, shape=Experience)) +
geom_point(position=pd) +
geom_line(position=pd) +
geom_errorbar(aes(min=ybar-SE, max=ybar+SE), position=pd, width=.2) +
ylab(y) +
NULL
label_i <- paste(y, stage_j, sep=".")
gg_list[[label_i]] <- gg
}
}
gg_list$Shoot_biomass.Seedling
gg_list$n_Leaves.Seedling
gg_list$Root.shoot_ratio.Seedling
gg_list$n_Leaves.Juvenile
gg_list$n_Leaves.Juvenile
gg_list$Biomass.Juvenile
gg_list$Root_biomass.Juvenile
library(cowplot)
install.packages("cowplot")
library(cowplot)
?plot_grid
plot_grid(gg_list, nrow=3, ncol=2)
plot_grid(gg_list$Shoot_biomass.Seedling,
gg_list$n_Leaves.Seedling,
gg_list$Root.shoot_ratio.Seedling,
gg_list$n_Leaves.Juvenile,
gg_list$Biomass.Juvenile,
gg_list$Root_biomass.Juvenile, nrow=3, ncol=2)
# gg_list$Shoot_biomass.Seedling
# gg_list$n_Leaves.Seedling
# gg_list$Root.shoot_ratio.Seedling
plot_grid(gg_list$Shoot_biomass.Seedling,
gg_list$n_Leaves.Juvenile,
gg_list$n_Leaves.Seedling,
gg_list$Biomass.Juvenile,
gg_list$Root.shoot_ratio.Seedling,
gg_list$Root_biomass.Juvenile, nrow=3, ncol=2)
# gg_list$Shoot_biomass.Seedling
# gg_list$n_Leaves.Seedling
# gg_list$Root.shoot_ratio.Seedling
plot_grid(gg_list$Shoot_biomass.Seedling,
gg_list$n_Leaves.Juvenile,
gg_list$n_Leaves.Seedling,
gg_list$Biomass.Juvenile,
gg_list$Root.shoot_ratio.Seedling,
gg_list$Root_biomass.Juvenile, nrow=3, ncol=2)
plot_grid(gg_list$Shoot_biomass.Seedling,
gg_list$n_Leaves.Juvenile,
gg_list$n_Leaves.Seedling,
gg_list$Biomass.Juvenile,
gg_list$Root.shoot_ratio.Seedling,
gg_list$Root_biomass.Juvenile, nrow=3, ncol=2)
# gg_list$Shoot_biomass.Seedling
# gg_list$n_Leaves.Seedling
# gg_list$Root.shoot_ratio.Seedling
YCOLS
ycols
names(exp2.b)
fn <- "table1.png"
if(knitr_path==TRUE){
image_path <- paste("../images", folder, fn, sep="/")
}else{
image_path <- paste("/images", folder, fn, sep="/")
}
knitr::include_graphics(image_path)
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="Seedling")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="Juvenile")
fit <- lm(Shoot_biomass ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, data=subdata)
fit <- lm(Shoot_biomass ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, data=exp2.b)
subdata <- function(dt, stage_j, xcols, y){
# this is a function used several times so making a function out of it
# stage_j is the stage
# xcols is the vector of labels of the columns of factors for the model
# y is the response column label
subdata_i <- dt[Stage==stage_j & N > 1, .SD, .SDcols=c(xcols, y)]
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata_i[Experience=="E", Population])
subdata_i[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata_i[Experience=="N", Population])
subdata_i[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata_i[, Population.cross:=factor(Population.cross)]
return(subdata_i)
}
stage_j <- "Seedling"
y
subdata_j <- exp2.b[Stage==stage_j & N > 1, .SD, .SDcols=c(xcols, y)]
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata_j[Experience=="E", Population])
subdata_j[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata_j[Experience=="N", Population])
subdata_j[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata_j[, Population.cross:=factor(Population.cross)]
subdata_i <- subdata(exp2.b, stage_j, xcols, y)
subdata_j==subdata_i
xcols <- c("Treatment", "Experience", "Population")
y <- "Shoot_biomass"
subdata_i <- subdata(exp2.b, "Seedling", xcols, y)
fit <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, data=subdata_i)
fit.emm <- emmeans(fit, specs=c("Experience"))
fit.contrast <- contrast(fit.emm, method="revpairwise")
xcols <- c("Treatment", "Experience", "Population")
y <- "Shoot_biomass"
subdata_i <- subdata(exp2.b, "Seedling", xcols, y)
fit <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, data=subdata_i)
fit.emm <- emmeans(fit, specs=c("Experience"))
(fit.contrast <- contrast(fit.emm, method="revpairwise"))
xcols <- c("Treatment", "Experience", "Population")
y <- "Shoot_biomass"
subdata_i <- subdata(exp2.b, "Seedling", xcols, y)
fit <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, data=subdata_i)
(fit.emm <- emmeans(fit, specs=c("Experience")))
(fit.contrast <- contrast(fit.emm, method="revpairwise"))
xcols <- c("Treatment", "Experience", "Population")
y <- "Shoot_biomass"
subdata_i <- subdata(exp2.b, "Seedling", xcols, y)
fit <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, data=subdata_i)
(fit.emm <- emmeans(fit, specs=c("Experience")))
(fit.contrast <- contrast(fit.emm, method="revpairwise"))
subdata_i[, (mean=mean(get(y))), by=Experience]
xcols <- c("Treatment", "Experience", "Population")
y <- "Shoot_biomass"
subdata_i <- subdata(exp2.b, "Seedling", xcols, y)
fit <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, data=subdata_i)
(fit.emm <- emmeans(fit, specs=c("Experience")))
(fit.contrast <- contrast(fit.emm, method="revpairwise"))
subdata_i[, (mean=mean(get(y)), sd=sd(get(y))), by=Experience]
xcols <- c("Treatment", "Experience", "Population")
y <- "Shoot_biomass"
subdata_i <- subdata(exp2.b, "Seedling", xcols, y)
fit <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, data=subdata_i)
(fit.emm <- emmeans(fit, specs=c("Experience")))
(fit.contrast <- contrast(fit.emm, method="revpairwise"))
subdata_i[, .(mean=mean(get(y)), sd=sd(get(y))), by=Experience]
table_i
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Shoot_biomass", "Root_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2.b, stage_j, xcols, y)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "Pr(>F)"])
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
}
}
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Shoot_biomass", "Root_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2.b, stage_j, xcols, y)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="Seedling")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="Seedling")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="Seedling")
ycols
y <- ycols[1]
stage_j
stage_j <- "Seedling"
subdata_i <- subdata(exp2.b, stage_j, xcols, y)
dim(subdata_i)
subdata_i$Longest_leaf
stage_j
exp2.b$Longest_leaf
sheet_i <- "Traits"
exp2 <- data.table(read_excel(file_path, sheet=sheet_i, na="x"))
exp2$`Longest leaf (cm)`
colnames(exp2) <- clean_label(colnames(exp2))
exp2[, Treatment:=factor(Treatment)]
exp2[, Experience:=factor(Population_Type)]
exp2[, Stage:=ifelse(as.character(Date)=="2012-04-30","Seedling", "Juvenile")]
exp2[, Exp_Pop:=factor(paste(Experience,Population,sep="."))]
exp2.b$Longest_leaf
exp2$Longest_leaf
exp2.b <- exp2[!is.na(n_Leaves) & Population!="Ana",]
counts <- exp2.b[, .(N=.N), by=.(Treatment, Experience, Population, Stage, Exp_Pop)]
exp2.b <- merge(exp2.b, counts, by=c("Treatment", "Experience", "Population", "Stage", "Exp_Pop"))
exp2.b$Longest_leaf
dim(exp2.b)
subdata <- function(dt, stage_j, xcols, y){
# this is a function used several times so making a function out of it
# stage_j is the stage
# xcols is the vector of labels of the columns of factors for the model
# y is the response column label
subdata_i <- dt[Stage==stage_j, .SD, .SDcols=c(xcols, y)]
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata_i[Experience=="E", Population])
subdata_i[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata_i[Experience=="N", Population])
subdata_i[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata_i[, Population.cross:=factor(Population.cross)]
return(subdata_i)
}
stage_j
subdata_i <- subdata(exp2.b, stage_j, xcols, y)
dim(subdata_i)
ycols[1]
exp2.b <- exp2[!is.na(Longest_leaf) & Population!="Ana",]
counts <- exp2.b[, .(N=.N), by=.(Treatment, Experience, Population, Stage, Exp_Pop)]
exp2.b <- merge(exp2.b, counts, by=c("Treatment", "Experience", "Population", "Stage", "Exp_Pop"))
subdata <- function(dt, stage_j, xcols, y){
# this is a function used several times so making a function out of it
# stage_j is the stage
# xcols is the vector of labels of the columns of factors for the model
# y is the response column label
# reduce to only relevant columns, stage, and delete Ana
subdata_i <- na.omit(dt[Stage==stage_j & Population!="Ana", .SD, .SDcols=c(xcols, y)])
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata_i[Experience=="E", Population])
subdata_i[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata_i[Experience=="N", Population])
subdata_i[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata_i[, Population.cross:=factor(Population.cross)]
return(subdata_i)
}
subdata_i <- subdata(exp2, stage_j, xcols, y)
dim(subdata_i)
subdata_i$Longest_leaf
head(subdata)
head(subdata_i)
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Shoot_biomass", "Root_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="Seedling")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="Seedling")
plot_grid(gg_list$Shoot_biomass.Seedling,
gg_list$n_Leaves.Juvenile,
gg_list$n_Leaves.Seedling,
gg_list$Biomass.Juvenile,
gg_list$Root.shoot_ratio.Seedling,
gg_list$Root_biomass.Juvenile, nrow=3, ncol=2)
# gg_list$Shoot_biomass.Seedling
# gg_list$n_Leaves.Seedling
# gg_list$Root.shoot_ratio.Seedling
subdata_i[1]
fit <- lmer(Root.shoot_ratio ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience + (1|Population), contrasts=con3, data=subdata_i)
fit <- lmer(Root.shoot_ratio ~  Treatment + Experience + Population + Treatment:Experience + (1|Population), contrasts=con3, data=subdata_i)
fit <- lmer(Root.shoot_ratio ~  Treatment + Experience + Population + Treatment:Experience, contrasts=con3, data=subdata_i)
fit <- lmer(Root.shoot_ratio ~  Treatment + Experience + Population + Treatment:Experience + (1|Experience/Population), contrasts=con3, data=subdata_i)
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience + Population.cross:Experience:Treatment, contrasts=con3, data=subdata_i)
drop1(fit3, .~., test="F")
y
y <- ycols[1]
y
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience + Population.cross:Experience:Treatment, contrasts=con3, data=subdata_i)
stage_j <- "Seedling"
subdata_i <- subdata(exp2, stage_j, xcols, y)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience + Population.cross:Experience:Treatment, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
table_i
58+12/60*1.05
(58+12/60)*1.05
cat(duck)
cat("duck")
cat("duck", "duck")
print("duck", "duck")
paste0("1", "2")
paste("1", "2")
