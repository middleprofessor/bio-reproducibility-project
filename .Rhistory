head(exp2)
dt <- exp2
stage_j <- "Juvenile"
xcols
u
y
y <- "Longest_leaf"
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j & Treatment="T", .(n=.N), by=Population]
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j & Treatment=="T", .(n=.N), by=Population]
n_pops
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j & Treatment=="T" & !is.na(y), .(n=.N), by=Population]
n_pops
y
counts
dt[Stage==stage_j & Treatment=="T" & !is.na(y)]
dt[Stage==stage_j & Treatment=="T" & !is.na(get(y)), .(n=.N), by=Population]
n_pops <- dt[Stage==stage_j & Treatment=="T" & !is.na(get(y)), .(n=.N), by=Population]
inc <- n_pops[n>1, Population]
inc
subdata <- function(dt, stage_j, xcols, y, inc_n=2){
# this is a function used several times so making a function out of it
# stage_j is the stage
# xcols is the vector of labels of the columns of factors for the model
# y is the response column label
# inc_n is the minimum n to include in the subdata
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j &
Treatment=="T" &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=Population]
inc <- n_pops[n>inc_n, Population]
# reduce to only relevant columns, stage, and delete Ana
subdata_i <- na.omit(dt[Stage==stage_j & Population %in% inc, .SD, .SDcols=c(xcols, y)])
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata_i[Experience=="E", Population])
subdata_i[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata_i[Experience=="N", Population])
subdata_i[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata_i[, Population.cross:=factor(Population.cross)]
return(subdata_i)
}
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Shoot_biomass", "Root_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Df"])
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], table_i[2:5, "Df"])
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
knitr::kable(df_table[["Juvenile"]], digits=0, caption="df")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Juvenile"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Df"])
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], table_i[2:5, "Df"])
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
subdata <- function(dt, stage_j, xcols, y, inc_n=2){
# this is a function used several times so making a function out of it
# stage_j is the stage
# xcols is the vector of labels of the columns of factors for the model
# y is the response column label
# inc_n is the minimum n to include in the subdata
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j &
Treatment=="T" &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=Population]
inc <- n_pops[n >= inc_n, Population]
# reduce to only relevant columns, stage, and delete Ana
subdata_i <- na.omit(dt[Stage==stage_j & Population %in% inc, .SD, .SDcols=c(xcols, y)])
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata_i[Experience=="E", Population])
subdata_i[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata_i[Experience=="N", Population])
subdata_i[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata_i[, Population.cross:=factor(Population.cross)]
return(subdata_i)
}
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y, inc_n=2)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Df"])
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], table_i[2:5, "Df"])
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
knitr::kable(df_table[["Juvenile"]], digits=0, caption="df")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Juvenile"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
n_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y, inc_n=2)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=c(row.names(table_i)[2:5], "n"),
c(table_i[2:5, "Df"], nrow(subdata_i)))
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], c(table_i[2:5, "Df"], nrow(subdata_i)))
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
knitr::kable(df_table[["Juvenile"]], digits=0, caption="df")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Juvenile"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
n_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y, inc_n=1)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=c(row.names(table_i)[2:5], "n"),
c(table_i[2:5, "Df"], nrow(subdata_i)))
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], c(table_i[2:5, "Df"], nrow(subdata_i)))
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
knitr::kable(df_table[["Juvenile"]], digits=0, caption="df")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Juvenile"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
n_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y, inc_n=0)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=c(row.names(table_i)[2:5], "n"),
c(table_i[2:5, "Df"], nrow(subdata_i)))
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], c(table_i[2:5, "Df"], nrow(subdata_i)))
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
n_table <- list()
y <- ycols[1]
stage_j
stage_j <- "Seedling"
dt <- copy(exp2)
dim(exp2)
inc_n <- 1
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j &
Treatment=="T" &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=Population]
inc <- n_pops[n >= inc_n, Population]
# reduce to only relevant columns, stage, and delete Ana
subdata_i <- na.omit(dt[Stage==stage_j & Population %in% inc, .SD, .SDcols=c(xcols, y)])
dim(subdata_i)
n_pops
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=.(Population, Treatment)]
n_pops
xcols
dt[Stage==stage_j &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=.(Exp_Pop, Treatment)]
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=.(Exp_Pop, Treatment)]
sum(n_pops$n)
sum(n_pops[n>3,n])
n_pops
# reduce to only relevant columns, stage, and delete Ana
subdata_i <- na.omit(dt[Stage==stage_j & Population %in% inc, .SD, .SDcols=c(xcols, y)])
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=.(Population)]
n_pops
subdata <- function(dt, stage_j, xcols, y, inc_n=2){
# this is a function used several times so making a function out of it
# stage_j is the stage
# xcols is the vector of labels of the columns of factors for the model
# y is the response column label
# inc_n is the minimum n to include in the subdata
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=.(Population)]
inc <- n_pops[n >= (5+inc_n), Population] # all Treatment="C" have n=5
# reduce to only relevant columns, stage, and delete Ana
subdata_i <- na.omit(dt[Stage==stage_j & Population %in% inc, .SD, .SDcols=c(xcols, y)])
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata_i[Experience=="E", Population])
subdata_i[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata_i[Experience=="N", Population])
subdata_i[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata_i[, Population.cross:=factor(Population.cross)]
return(subdata_i)
}
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
n_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y, inc_n=0)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=c(row.names(table_i)[2:5], "n"),
c(table_i[2:5, "Df"], nrow(subdata_i)))
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], c(table_i[2:5, "Df"], nrow(subdata_i)))
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
knitr::kable(df_table[["Juvenile"]], digits=0, caption="df")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Juvenile"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
subdata <- function(dt, stage_j, xcols, y, min_n=2){
# this is a function used several times so making a function out of it
# stage_j is the stage
# xcols is the vector of labels of the columns of factors for the model
# y is the response column label
# min_n is the minimum n to include in the subdata
#first get populations with n>1 in Treatment="T"
n_pops <- dt[Stage==stage_j &
!is.na(get(y)) &
Population != "Ana", .(n=.N), by=.(Population)]
inc <- n_pops[n >= (5+min_n), Population] # all Treatment="C" have n=5
# reduce to only relevant columns, stage, and delete Ana
subdata_i <- na.omit(dt[Stage==stage_j & Population %in% inc, .SD, .SDcols=c(xcols, y)])
# recode Populations to 1:n_pop; this is only way to analyze as fixed using aov
# subdata[, Population2:=Population]
popsE <- unique(subdata_i[Experience=="E", Population])
subdata_i[Population %in% popsE, Population.cross:= mapvalues(Population, from = popsE, to = as.character(1:length(popsE)))]
popsN <- unique(subdata_i[Experience=="N", Population])
subdata_i[Population %in% popsN, Population.cross:= mapvalues(Population, from = popsN, to = as.character(1:length(popsN)))]
subdata_i[, Population.cross:=factor(Population.cross)]
return(subdata_i)
}
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
n_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y, min_n=2)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=c(row.names(table_i)[2:5], "n"),
c(table_i[2:5, "Df"], nrow(subdata_i)))
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], c(table_i[2:5, "Df"], nrow(subdata_i)))
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
knitr::kable(df_table[["Juvenile"]], digits=0, caption="df")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Juvenile"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
knitr::kable(df_table[["Juvenile"]], digits=0, caption="df")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Juvenile"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
xcols <- c("Treatment", "Experience", "Stage", "Population", "Exp_Pop")
ycols <- c("Longest_leaf", "n_Leaves", "Biomass", "Root_biomass", "Shoot_biomass", "Root.shoot_ratio")
con3 <- list(Treatment=contr.sum, Experience=contr.sum) # change the contrasts coding for the model matrix
f_table <- list()
p_table <- list()
df_table <- list()
n_table <- list()
for(stage_j in c("Seedling", "Juvenile")){
for(y in ycols){
subdata_i <- subdata(exp2, stage_j, xcols, y, min_n=0)
# the best I can do. I explicitly ordered the terms this way to match table 1
fit3 <- lm(get(y) ~  Treatment + Experience + Population.cross%in%Experience + Treatment:Experience, contrasts=con3, data=subdata_i)
table_i <- drop1(fit3, .~., test="F") # matches JMP except Experience row
# these do not run because of singular xtxi matrix
# Anova(fit3, type="3")
# form_i <- formula(paste(y, "~ Treatment*Experience + Population.cross%in%Experience"))
# fit <- gls(form_i, weights=varIdent(form=~1|Population), data=subdata_i) # singular
if(y==ycols[1]){
f_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "F value"])
p_table[[stage_j]] <- data.table(terms=row.names(table_i)[2:5],
table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- data.table(terms=c(row.names(table_i)[2:5], "n"),
c(table_i[2:5, "Df"], nrow(subdata_i)))
}else{
f_table[[stage_j]] <- cbind(f_table[[stage_j]], table_i[2:5, "F value"])
p_table[[stage_j]] <- cbind(p_table[[stage_j]], table_i[2:5, "Pr(>F)"])
df_table[[stage_j]] <- cbind(df_table[[stage_j]], c(table_i[2:5, "Df"], nrow(subdata_i)))
}
setnames(f_table[[stage_j]], old="V2", new=y)
setnames(p_table[[stage_j]], old="V2", new=y)
setnames(df_table[[stage_j]], old="V2", new=y)
}
}
knitr::kable(df_table[["Seedling"]], digits=0, caption="df")
knitr::kable(f_table[["Seedling"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Seedling"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
knitr::kable(df_table[["Juvenile"]], digits=0, caption="df")
knitr::kable(f_table[["Juvenile"]], digits=c(NA, 2, 2, 2, 2, 2, 2), caption="F-value")
knitr::kable(p_table[["Juvenile"]], digits=c(NA, 3, 3, 3, 3, 3, 3), caption="P-value")
